# Creation of the analysis tables 🦆⚽

We now have our data in two tables in the _staging_ scehma but it is not yet analysis ready. Just to recap, our raw data table names are:

1. season_1992_1993_raw
1. seasons_1993_2023_raw


We are also going to create and populate another table in schema _main_ called _clubs_ to map club names to commonly used three letter club codes. The data for this small look-up table was pre-prepared in Google Sheets 

The clean up we will need to do on our two raw to tables to get to analysis-ready data is usually required; we are rarely given analysis-ready data and if we are, it usually means someone somewhere put in considerable effort  to clean the data for us. The task we will see here also showcase DuckDB's excellent data wrangling capabilities; it really is a first class tool for these types of task and I will highlight its impressive strengths in this regard as we transform our raw data into clean, analysis-ready tables.


## Table _clubs_

### Table creation

We create the table in schema _main_ using the following SQL

```sql
USE main; -- Ensure this table is created in schema main
CREATE OR REPLACE TABLE clubs(
  club_code VARCHAR PRIMARY KEY,
  club_name VARCHAR,
  club_given_name VARCHAR);
```

I have added a primary key, the club code, to ensure that the club code is unique. We are not building a transactional database (OLTP) but rather an analytical one so I will not spend much time discussing database keys or database design but I will add primary and foreign keys if it makes sense to do so.

__Note__: The "OR REPLACE" is a non-standard DuckDB addition to SQL. It is standard SQL for view creation but in SQLite or  we would need a "DROP TABLE IF EXISTS <table_name>;" to get the same effect. DuckDB supports this syntax too so we could use it if compatibility was a concern.

### Commenting a table and its columns

A nice feature of DuckDB is the ability to add comments to objects that are stored in its system catalogs. The syntax is identical PostgreSQL and we will add comments to all our tables, their columns, views as macros as we proceed.

```sql
COMMENT ON TABLE clubs IS 'A lookup that maps club three-letter codes to names given in source files and the official club name. Records every club that has played in at least one EPL season.';
COMMENT ON COLUMN clubs.club_code IS 'A recognised uppercase three letter code for clubs to be used in other tables.';
COMMENT ON COLUMN clubs.club_name IS 'The official name of the club.';
COMMENT ON COLUMN clubs.club_given_name IS 'The club name used in source files which may or may not be the same as the official club name.';
```
### Populating the table

The file which was curated in Google Sheets and then exported as a TSV is uploaded into our new, heavily commented table as follows:

```sql
INSERT INTO clubs(club_code,
                  club_name, 
                  club_given_name) 
SELECT 
  club_code, 
  club_name, 
  given_name 
FROM '../source_data/clubs.tsv';
```

__Note__: The three letter codes i have used here are those used by Wikipedia. I am not sure if they are official but they are suitable identifiers because they are both short and unambiguous while club names are tedious to type and ambiguous; is it "Manchester United", "Man U", or just "United"? The three letter code "MUN" is much easier. When we want to use the full club name, in reports for example, we can join to this table to get it.



## Create the _matches_ table

This is our main table and it records details for all EPL matches played from season 1992_1993 to season 2023_2024. We will create the table in schema _main_ and then populate it with the data we validate and format from the raw tables in schema _staging_

```sql
USE main;
CREATE SEQUENCE seq_match_id START 1;
CREATE OR REPLACE TABLE matches(
  mid INTEGER PRIMARY KEY DEFAULT NEXTVAL('seq_match_id'),
  season TEXT NOT NULL,
  mdate DATE,
  mtime TIME,
  hcc TEXT NOT NULL,
  acc TEXT NOT NULL,
  hcg TINYINT NOT NULL,
  acg TINYINT NOT NULL
);
```
### Use of sequences

We have used the _sequence_ object to create a monotonically increasing number which use as a primary key. while not strictly necessary, it is useful to allow us to easily identify individual matches and the ID will be generated automatically when we insert rows later.

### Document our table

We will add comments as we did for table _clubs_.

```sql
COMMENT ON TABLE matches IS 'A record of clubs, goals scored/conceded with time and date details (if available) for every match from season 1992_1993 to 2023_2024.';
COMMENT ON COLUMN matches.mid IS 'The match ID: Primary key autogenerated from a sequence.';
COMMENT ON COLUMN matches.season IS 'The season the match was played in.';
COMMENT ON COLUMN matches.mdate IS 'The date on which the match was played, if available.';
COMMENT ON COLUMN matches.mtime IS 'The time the match was played. Data only available for recent seasons.';
COMMENT ON COLUMN matches.hcc IS 'Home club code: The club playing at its home stadium/';
COMMENT ON COLUMN matches.acc IS 'Away club code: The club playing away from its home stadium';
COMMENT ON COLUMN matches.hcg IS 'Home club goals: The number of goals scored by the home club.';
COMMENT ON COLUMN matches.acg IS 'Away club goals: The number of goals scored by the away club.';
```
__Note__: I have deliberately used short column names for the table but I have fully spelled out the columns' purpose in the comments where the abbreviated names are explained; "acc" means "Away Club Code", for example. This approach makes query writing simpler and we can avoid using aliases.

## Insert data into the table _matches_

Our _matches_ is now ready to receive data but before we insert it, we need to check it and clean it up.

### Season 1992-1993

The data giving match scores for season 1992-1993 was downloaded from Wikipedia as discussed in the [previous post](https://rotifer.github.io/2025/01/04/loading-and-viewing-data-in-duckdb.html). It is in a pivot format that uses row names to represent the home club and column names to represent the away club with the intersection cell giving the score as home club goals scored followed by a dash of some sort followed by the away club goals scored.


First question: What is the dash-like character separating the score in the data cells?

VS Code says: "The character U+2013 "–" could be confused with the ASCII character U+002d "-", which is more common in source code"

[What is "endash"](https://stackoverflow.com/questions/59839683/en-dash-giving-different-ascii-values()

Our final objective is to create a version of the data for this season which we can integrate with the data for all other seasons. We will do this step-wise and create intermediate tables at each step. Each intermediate table will be the input for the subsequent step. Once we have achieved our goal, we will remove the intermediate tables. Note, all of this activity takes place in the _staging_ schema.

#### Un-pivoting

We need to "unpivot" the data, that is turn the "wide and short" representation into "long and thin". Hadley Wickham of R fame describes the long thin format as ["tidy data"](https://vita.had.co.nz/papers/tidy-data.pdf)
The DuckDB documentation on unpivoting is excellent: [UNPIVOT Statement](https://duckdb.org/docs/sql/statements/unpivot.html)

```sql
USE staging;
CREATE OR REPLACE TABLE season_1992_1993_unpivot AS
UNPIVOT season_1992_1993_raw
ON COLUMNS(* EXCLUDE "Home \ Away")
INTO
  NAME away_club_code
  VALUE score;
```



#### Beaking the scores into home and away columns

The scores are separated by that odd _endash_ character and we need to break them appart. The _STRING_SPLIT_ is one of the many very useful DuckDB string functions and it takes the string and the split character (CHR(8211) represents endash) to return an array. We extract the two elements from this array  using the array element access notation []. DuckDB arrays are 1-based so [1] returns the home club goals while [2] returns the away club goals.

```sql
CREATE OR REPLACE TABLE season_1992_1993_scores AS
SELECT
  "Home \ Away" AS home_club_name,
  away_club_code,
  STRING_SPLIT(score, CHR(8211))[1] home_club_score,
  STRING_SPLIT(score, CHR(8211))[2] away_club_score
FROM season_1992_1993_unpivot;
```

#### Remove self v self rows

The DELETE relies on the fact that rows where the home and away club is the same the second element returned by the _STRING_SPLIT_ function will be _NULL_.

Check the count before the delete:

```sql
SELECT COUNT(*)
FROM season_1992_1993_scores; -- -> 484
```

```sql
DELETE FROM season_1992_1993_scores
WHERE away_club_score IS NULL;
```

```sql
SELECT COUNT(*)
FROM season_1992_1993_scores; -- -> 462
```


#### CAST scores to integer type

Our scores are stored as strings (column type VARCHAR) but we want to convert them (CAST) to inmtegers.

```sql
CREATE OR REPLACE TABLE season_1992_1993_int_scores
AS
SELECT
  home_club_name,
  away_club_code,
  CAST(home_club_score AS TINYINT) home_club_score,
  CAST(away_club_score AS TINYINT) away_club_score
FROM season_1992_1993_scores;
```

Note, I have used TINYINT as the column type for scores because these is no need to use a larger integer type.


#### Join tables to convert club name to club code

Our data is almost ready to be loaded into our table _matches_ in schema _main_ but we need to do one more thing: convert the home club name to the home club code (_hcc_ in table _matches_). We can achieve this by joining to our _clubs_ table

```sql
CREATE OR REPLACE TABLE season_1992_ready AS
SELECT
  '1992_1993' season,
  NULL mdate,
  NULL mtime,
  c.club_code hcc,
  sis.away_club_code acc,
  sis.home_club_score hcg,
  sis.away_club_score acg
FROM
  season_1992_1993_int_scores sis
  JOIN main.clubs c
    ON sis.home_club_name = c.club_name;
```

This table's data is now ready to be inserted into _matches_. The join replaces the club name with the club code and we have added three columns:

1. _season_: We know the rows relate to season _'1992_1993'_ so we repeat this string for every row.
2. We do not have the match dates so we just repeat NULL for each row and name the column _mdate_.
3. Similary for _mtime_, we repeat NULLS for this column also.

Filling in these columns isn't strictly necessary but I did it to emphasize home we can explicitly highlight NULLs for columns and to make the table the same structure as _matches_.

#### Append the data to table _matches_

A simple append query works here. Note, this query is executed from schema _main_ so we have to qualify the source table name with its schema in the FROM clause.

```sql
USE main;
INSERT INTO matches(season,
                    mdate,
                    mtime,
                    hcc,
                    acc,
                    hcg,
                    acg)
SELECT
  season,
  mdate,
  mtime,
  hcc,
  acc,
  hcg,
  acg
FROM
  staging.season_1992_ready;
```

👏👏 We now have data for our first season in the table _matches_. You can run a `SELECT COUNT(*) FROM matches`` to verify insertion of 462 rows. Our table is analysis-ready but unfortunately we don't have the match dates so we will need to be aware of this fact when we run queries for all seasons. Missing data is common and needs to be taken into account in analyses.

Clean up: We can `DROP` our intermediate tables now:

```sql
USE staging;
DROP TABLE season_1992_1993_unpivot;
DROP TABLE season_1992_1993_scores;
DROP TABLE season_1992_1993_int_scores;
DROP TABLE season_1992_ready;
```

## Seasons 1993_1994 to 2023_2024


```sql
CREATE OR REPLACE TABLE staging.epl_matches_1992_2024 AS
WITH matches_temp AS(
  SELECT
    '1992_1993' season,
    NULL match_date,
    NULL match_time,
    home_club_code,
    away_club_code,
    home_club_score,
    away_club_score
  FROM season_1992_1993_ready
  UNION
  SELECT
    season,
    CASE
      WHEN REGEXP_MATCHES(match_date, '\d{2}\/\d{2}\/\d{2}$') THEN
        STRPTIME(match_date, '%d/%m/%y') 
      WHEN REGEXP_MATCHES(match_date, '\d{2}\/\d{2}\/\d{4}$') THEN
        STRPTIME(match_date, '%d/%m/%Y')
    END match_date,
    CASE
      WHEN match_time = 'NA' THEN NULL
      ELSE CAST(match_time AS TIME)
    END match_time,
    (SELECT club_code 
     FROM macros.get_club_code(home_club_name)) home_club_code,
    (SELECT club_code 
     FROM macros.get_club_code(away_club_name)) away_club_code,
    home_club_goals,
    away_club_goals
  FROM seasons_1993_2023_raw
  WHERE home_club_name IS NOT NULL
)
SELECT
  *
FROM  matches_temp;
```


```sql
COPY epl_matches_1992_2024 TO '../output_data/epl_matches_1992_2024.csv' (FORMAT 'csv', DELIMITER ',', HEADER true);
```

### Fix the date fields

```sql
SELECT match_date FROM seasons_1993_2023_raw WHERE REGEXP_MATCHES(match_date, '\d{2}\/\d{2}\/\d{2}$');
```


### date issue

```sql
select strptime('14/05/00', '%d/%m/%Y');
select strptime('14/05/01', '%d/%m/%Y');
select strptime('14/05/00', '%d/%m/%y');
```

## Create the final table

```sql
CREATE SEQUENCE seq_match_id START 1;
CREATE OR REPLACE TABLE main.matches(
  mid INTEGER PRIMARY KEY DEFAULT NEXTVAL('seq_match_id'),
  season TEXT NOT NULL,
  mdate DATE,
  mtime TIME,
  hcc TEXT NOT NULL,
  acc TEXT NOT NULL,
  hcg TINYINT NOT NULL,
  acg TINYINT NOT NULL
);
```

### Move the data from the temp table

```sql
INSERT INTO matches(season,
                    mdate,
                    mtime,
                    hcc,
                    acc,
                    hcg,
                    acg)
SELECT
  season,
  match_date,
  match_time,
  home_club_code,
  away_club_code,
  home_club_score,
  away_club_score
FROM staging.epl_matches_1992_2024
ORDER BY season, match_date, match_time, home_club_code;
```

- Create the table in schema main 
- Add a match id column using a sequence
- Insert the data from the staging table in a defined order
- Export the final table t0 an output file

```sql
COPY matches TO '../output_data/matches.csv' (FORMAT 'csv', DELIMITER ',', HEADER true);
```


## Create the league tables

### Create an empty table

```sql
CREATE OR REPLACE TABLE ltables(
  season VARCHAR,
  ccode VARCHAR,
  played TINYINT,
  won TINYINT,
  drawn TINYINT,
  lost TINYINT,
  scored INT,
  conceded INT,
  goal_diff INT,
  points TINYINT
);
```


```sql
WITH mresults AS(
  SELECT
    mid,
    season,
    hcc ccode,
    hcg scored,
    acg conceded,
    CASE
      WHEN hcg = acg THEN 1
      WHEN hcg > acg THEN 3
      ELSE 0
    END points,
    CASE
      WHEN hcg > acg THEN 1
      ELSE 0
    END won,
    CASE
      WHEN hcg = acg THEN 1
      ELSE 0
    END drawn,
    CASE
      WHEN hcg < acg THEN 1
      ELSE 0
    END lost
  FROM matches
  UNION
  SELECT
    mid,
    season,
    acc,
    acg scored,
    hcg conceded,
    CASE
      WHEN acg = hcg THEN 1
      WHEN acg > hcg THEN 3
      ELSE 0
    END points,
    CASE
      WHEN acg > hcg THEN 1
      ELSE 0
    END won,
    CASE
      WHEN acg = hcg THEN 1
      ELSE 0
    END drawn,
    CASE
      WHEN acg < hcg THEN 1
      ELSE 0
    END lost
  FROM matches
),
season_summary AS(
  SELECT
    season,
    ccode,
    COUNT(mid) played,
    SUM(won) won,
    SUM(drawn) drawn,
    SUM(lost) lost,
    SUM(scored) scored,
    SUM(conceded) conceded,
    SUM(scored - conceded) goal_diff,
    SUM(points) points
  FROM mresults
  GROUP BY season, ccode
)
INSERT INTO ltables(
  season,
  ccode,
  played,
  won,
  drawn,
  lost,
  scored,
  conceded,
  goal_diff,
  points
)
SELECT
  season,
  ccode,
  played,
  won,
  drawn,
  lost,
  scored,
  conceded,
  goal_diff,
  points
FROM season_summary;
```

### Export ltables

```sql
COPY ltables TO '../output_data/ltables.csv' (FORMAT 'csv', DELIMITER ',', HEADER true);
```